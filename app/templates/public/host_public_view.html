{% extends "base.html" %}

{% block title %}{{ host.name }} - Public View{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <!-- Wake animation overlay -->
        <div class="wake-animation-overlay" id="wakeAnimationOverlay">
            <div class="wake-animation-container">
                <!-- Close button -->
                <button class="wake-close-button" id="wakeCloseButton">
                    <i class="fas fa-times"></i>
                </button>
                <!-- Animation area -->
                <div class="animation-area">
                    <div class="signal-waves">
                        <div class="wave wave1"></div>
                        <div class="wave wave2"></div>
                        <div class="wave wave3"></div>
                        <div class="wave wave4"></div>
                    </div>
                    <div class="pulse-circle"></div>
                    <div class="packet-container">
                        <div class="packet packet1"></div>
                        <div class="packet packet2"></div>
                        <div class="packet packet3"></div>
                    </div>
                </div>
                <!-- Text area - completely separate from animation -->
                <div class="wake-text">
                    <div class="wake-text-title">Waking Up Host</div>
                    <div class="wake-text-subtitle">Sending Magic Packet</div>
                    <div class="wake-text-status">Waiting for response...</div>
                    <div class="wake-progress-container">
                        <div class="wake-progress-bar"></div>
                    </div>
                    <div class="wake-result success">
                        <i class="fas fa-check-circle wake-icon-success"></i>
                        <div class="wake-result-text">Host Online</div>
                    </div>
                    <div class="wake-result failure">
                        <i class="fas fa-exclamation-triangle wake-icon-failure"></i>
                        <div class="wake-result-text">Wake Failed</div>
                        <div class="wake-retry-button">Try Again</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div class="card host-card shadow-lg border-0">
                <!-- Animated background -->
                <div class="animated-background">
                    <svg class="animated-paths" viewBox="-400 -250 800 500" preserveAspectRatio="xMidYMid slice">
                        <!-- SVG paths will be generated by JavaScript -->
                    </svg>
                </div>
                <!-- Card content -->
                <div class="card-header d-flex justify-content-between align-items-center bg-gradient-primary text-white py-3">
                    <h4 class="card-title mb-0 fw-bold">
                        <i class="fas fa-server me-2"></i>{{ host.name }}
                    </h4>
                    {% if host.status == 'online' %}
                        <span class="badge bg-success status-badge" id="host-{{ host.id }}-status" data-status="online">
                            <i class="fas fa-circle-check fa-xs me-1"></i>online
                        </span>
                    {% elif host.status == 'offline' %}
                        <span class="badge bg-danger status-badge" id="host-{{ host.id }}-status" data-status="offline">
                            <i class="fas fa-circle-xmark fa-xs me-1"></i>offline
                        </span>
                    {% else %}
                        <span class="badge bg-secondary status-badge" id="host-{{ host.id }}-status" data-status="unknown">
                            <i class="fas fa-circle-question fa-xs me-1"></i>unknown
                        </span>
                    {% endif %}
                </div>
                <div class="card-body p-4">
                    <div class="host-info mb-4">
                        <div class="row align-items-center">
                            <div class="col-md-6">
                                <div class="info-item mb-3">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-mac">
                                            <i class="fas fa-network-wired"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">MAC Address</h6>
                                            <p class="mb-0 mac-address fw-bold">{{ host.mac_address }}</p>
                                        </div>
                                    </div>
                                </div>
                                
                                {% if host.description %}
                                <div class="info-item mb-3">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-info">
                                            <i class="fas fa-info-circle"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">Description</h6>
                                            <p class="mb-0">{{ host.description }}</p>
                                        </div>
                                    </div>
                                </div>
                                {% endif %}
                                
                                <div class="info-item">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-time">
                                            <i class="fas fa-clock"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">Last Check</h6>
                                            <p class="mb-0" id="host-{{ host.id }}-last-check">
                                                Checking status...
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6 d-flex flex-column align-items-center justify-content-center mt-4 mt-md-0">
                                <form method="post" action="{{ url_for('public.wake_host') }}" id="wakeHostForm" class="text-center">
                                    <input type="hidden" name="host_id" value="{{ host.id }}">
                                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                                    <div class="wake-button-container">
                                        <button type="button" id="wakeHostBtn" 
                                            class="wake-button-circle btn-animate-press {% if host.status == 'online' %}online{% elif host.status == 'offline' %}offline{% else %}unknown{% endif %}"
                                            data-status="{{ host.status }}" data-host-id="{{ host.id }}">
                                            <div class="button-inner">
                                                <i class="fas fa-power-off power-icon"></i>
                                                <span class="button-text">Wake Host</span>
                                            </div>
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-footer bg-light py-3 text-center">
                    <small class="text-muted">Powered by WOL Manager</small>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function() {
    function updateHostStatuses() {
        // Extract the token from the current URL
        const pathSegments = window.location.pathname.split('/');
        const token = pathSegments[pathSegments.length - 1];
        
        fetch(`/public/host/${token}/status`)
            .then(response => response.json())
            .then(data => {
                const statusBadge = document.querySelector(`#host-${data.host_id}-status`);
                const wakeButton = document.querySelector('#wakeHostBtn');
                
                if (statusBadge) {
                    // Update status badge with more obvious animations
                    if (typeof window.updateStatusBadgeAnimation === 'function') {
                        // Use the enhanced animation function if available
                        window.updateStatusBadgeAnimation(`host-${data.host_id}-status`, data.status);
                    } else {
                        // Fallback to basic update
                        statusBadge.setAttribute('data-status', data.status);
                        
                        // Update badge background classes
                        statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-secondary');
                        if (data.status === 'online') {
                            statusBadge.classList.add('bg-success');
                        } else if (data.status === 'offline') {
                            statusBadge.classList.add('bg-danger');
                        } else {
                            statusBadge.classList.add('bg-secondary');
                        }
                        
                        // Update icon and text
                        let icon = '<i class="fas fa-circle-question fa-xs me-1"></i>';
                        if (data.status === 'online') {
                            icon = '<i class="fas fa-circle-check fa-xs me-1"></i>';
                        } else if (data.status === 'offline') {
                            icon = '<i class="fas fa-circle-xmark fa-xs me-1"></i>';
                        }
                        statusBadge.innerHTML = icon + data.status;
                    }
                    
                    // Update wake button status
                    if (wakeButton) {
                        wakeButton.classList.remove('online', 'offline', 'unknown');
                        wakeButton.classList.add(data.status);
                        wakeButton.setAttribute('data-status', data.status);
                    }
                    
                    // Update last check time
                    const lastCheck = document.querySelector(`#host-${data.host_id}-last-check`);
                    if (lastCheck && data.last_check) {
                        const date = new Date(data.last_check);
                        lastCheck.textContent = date.toLocaleString();
                    }
                }
            })
            .catch(error => {
                console.error('Error updating host statuses:', error);
            });
    }

    // Add a subtle entrance animation to the card
    const hostCard = document.querySelector('.host-card');
    if (hostCard) {
        hostCard.style.animation = 'cardEntrance 0.6s var(--animation-spring) forwards';
    }

    // Update initially and then every 15 seconds
    updateHostStatuses();
    setInterval(updateHostStatuses, 15000);
    
    // Handle wake button click with confirmation dialog
    const wakeHostBtn = document.querySelector('#wakeHostBtn');
    const wakeHostForm = document.querySelector('#wakeHostForm');
    
    if (wakeHostBtn && wakeHostForm) {
        // Remove any existing event listeners and create a new one
        const newWakeHostBtn = wakeHostBtn.cloneNode(true);
        wakeHostBtn.parentNode.replaceChild(newWakeHostBtn, wakeHostBtn);
        
        newWakeHostBtn.addEventListener('click', function() {
            const status = this.getAttribute('data-status');
            
            if (status === 'online') {
                // Show confirmation dialog for online hosts
                if (confirm('This host appears to be online already. Do you still want to wake it?')) {
                    showWakeAnimation();
                }
            } else {
                // No confirmation needed for offline hosts
                showWakeAnimation();
            }
        });
    }
    
    // Generate animated SVG paths
    function generateAnimatedPaths() {
        const svg = document.querySelector('.animated-paths');
        if (!svg) return;
        
        // Clear existing paths
        svg.innerHTML = '';
        
        // Get host status to set color theme
        const wakeButton = document.querySelector('#wakeHostBtn');
        const hostStatus = wakeButton ? wakeButton.getAttribute('data-status') : 'unknown';
        
        // Set color variables based on host status
        let primaryColor, secondaryColor, opacity;
        
        if (hostStatus === 'online') {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim() || '#28a745';
            secondaryColor = '#50c878';
            opacity = 0.07;
        } else if (hostStatus === 'offline') {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim() || '#dc3545';
            secondaryColor = '#ff5757';
            opacity = 0.07;
        } else {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#007bff';
            secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || '#6610f2';
            opacity = 0.07;
        }
        
        // Check for dark theme
        const isDarkTheme = document.body.classList.contains('dark-theme');
        if (isDarkTheme) {
            opacity = 0.12; // Higher opacity for dark theme for better visibility
        }
        
        // Generate paths (similar to the React example)
        const numberOfPaths = 42; // Increased number of paths for more intensity
        
        // Pre-calculate path parameters for symmetry
        const pathParams = [];
        
        // Fixed lengths for lines to make them shorter with quicker transitions
        const fixedLineLengths = [100, 150, 200, 250, 300]; // Shorter lengths for circuit paths
        
        // Create symmetrical starting points
        const xOffsets = [];
        const yOffsets = [];
        
        // Generate symmetric distribution of points
        for (let i = 0; i < numberOfPaths; i++) {
            // Create mirror patterns for x/y offsets
            const mirrorIndex = numberOfPaths - i - 1;
            const normalizedPos = i / (numberOfPaths - 1); // 0 to 1
            
            // Create a more spread out grid of starting points covering the entire background
            // Calculate positions using quadrant-based approach for better distribution
            const quadrant = i % 4; // 0: top-left, 1: top-right, 2: bottom-right, 3: bottom-left
            const posInQuadrant = Math.floor(i / 4) / Math.ceil(numberOfPaths / 4);
            
            if (quadrant === 0) {
                // Top-left quadrant
                xOffsets[i] = -380 + (posInQuadrant * 190);
                yOffsets[i] = -230 + (posInQuadrant * 115);
            } else if (quadrant === 1) {
                // Top-right quadrant
                xOffsets[i] = 0 + (posInQuadrant * 190);
                yOffsets[i] = -230 + (posInQuadrant * 115);
            } else if (quadrant === 2) {
                // Bottom-right quadrant
                xOffsets[i] = 0 + (posInQuadrant * 190);
                yOffsets[i] = 0 + (posInQuadrant * 115);
            } else {
                // Bottom-left quadrant
                xOffsets[i] = -380 + (posInQuadrant * 190);
                yOffsets[i] = 0 + (posInQuadrant * 115);
            }
            
            // Add slight randomization to prevent too much symmetry
            xOffsets[i] += (Math.random() * 40) - 20;
            yOffsets[i] += (Math.random() * 40) - 20;
        }
        
        for (let i = 0; i < numberOfPaths; i++) {
            // Calculate parameters with symmetry in mind
            const pathOpacity = opacity + (i * 0.01);
            const pathWidth = 0.6 + (i * 0.07);
            // Create symmetrical delay pattern
            const normalizedPos = i / (numberOfPaths - 1); // 0 to 1
            const delay = normalizedPos * 8; // Spread delays evenly across 8 seconds
            const duration = 15 + (i % 5) * 3; // More consistent durations
            const pathType = i % 5;
            
            // Store all params including the symmetric offsets
            pathParams.push({ 
                pathOpacity, 
                pathWidth, 
                delay, 
                duration: duration * 0.7, // Shorter overall duration for quicker animations
                pathType,
                xOffset: xOffsets[i] || 0,
                yOffset: yOffsets[i] || 0,
                // Assign a fixed line length to each path
                fixedLength: fixedLineLengths[i % fixedLineLengths.length]
            });
        }
        
        for (let i = 0; i < numberOfPaths; i++) {
            // Create random path data
            const { pathOpacity, pathWidth, delay, duration, pathType, xOffset, yOffset, fixedLength } = pathParams[i];
            
            // Create circuit-like paths with right angles instead of curves
            let d = '';
            
            // Helper function to create circuit paths with 90-degree angles
            const createCircuitPath = () => {
                // Start point
                let x = xOffset;
                let y = yOffset;
                
                // Define number of segments (turns) in the path
                const segments = 3 + (i % 4); // 3-6 segments for longer paths
                
                // Start the path
                d = `M${x},${y} `;
                
                // Create segments with right angles
                for (let s = 0; s < segments; s++) {
                    // More varied directions based on position to create paths that radiate outward
                    // This helps spread the animation across the background
                    let direction;
                    
                    if (x < -150 && y < -100) {
                        // Top-left: tend to go right and down
                        direction = [0, 1][s % 2];
                    } else if (x > 150 && y < -100) {
                        // Top-right: tend to go left and down
                        direction = [2, 1][s % 2];
                    } else if (x > 150 && y > 100) {
                        // Bottom-right: tend to go left and up
                        direction = [2, 3][s % 2];
                    } else if (x < -150 && y > 100) {
                        // Bottom-left: tend to go right and up
                        direction = [0, 3][s % 2];
                    } else if (Math.abs(x) < 150 && y < -100) {
                        // Top-center: tend to go down
                        direction = [0, 1, 2, 1][s % 4];
                    } else if (Math.abs(x) < 150 && y > 100) {
                        // Bottom-center: tend to go up
                        direction = [0, 3, 2, 3][s % 4];
                    } else if (x < -150 && Math.abs(y) < 100) {
                        // Left-center: tend to go right
                        direction = [0, 1, 0, 3][s % 4];
                    } else if (x > 150 && Math.abs(y) < 100) {
                        // Right-center: tend to go left
                        direction = [2, 1, 2, 3][s % 4];
                    } else {
                        // Center: random
                        direction = s % 4;
                    }
                    
                    // Calculate length of this segment (shorter near edges)
                    let segmentLength = 50 + (i % 7) * 20; // Longer segments to reach further
                    
                    // Cap length if getting too close to edges
                    if (direction === 0 && x > 350) segmentLength = 30; // Right edge
                    if (direction === 1 && y > 220) segmentLength = 30; // Bottom edge
                    if (direction === 2 && x < -350) segmentLength = 30; // Left edge
                    if (direction === 3 && y < -220) segmentLength = 30; // Top edge
                    
                    // Create right-angled segments
                    if (direction === 0) { // Horizontal right
                        x += segmentLength;
                        d += `h${segmentLength} `;
                    } else if (direction === 1) { // Vertical down
                        y += segmentLength;
                        d += `v${segmentLength} `;
                    } else if (direction === 2) { // Horizontal left
                        x -= segmentLength;
                        d += `h-${segmentLength} `;
                    } else { // Vertical up
                        y -= segmentLength;
                        d += `v-${segmentLength} `;
                    }
                    
                    // Add a circle node at each turn (except the last one)
                    if (s < segments - 1) {
                        d += `M${x},${y} `;
                    }
                }
                
                return d;
            };
            
            // Create circuit paths with different patterns
            if (pathType === 0) {
                // Horizontal dominant circuit
                d = createCircuitPath();
            } else if (pathType === 1) {
                // Vertical dominant circuit
                d = createCircuitPath();
            } else if (pathType === 2) {
                // Diagonal-like circuit with many turns
                d = createCircuitPath();
            } else if (pathType === 3) {
                // Long horizontal with small vertical jigs
                d = createCircuitPath();
            } else {
                // Complex circuit with multiple branches
                d = createCircuitPath();
            }
            
            // Create the SVG path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', d);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'square');  // Sharp corners for circuit look
            path.setAttribute('stroke-linejoin', 'miter');  // Sharp joins for circuit look
            
            // Circuit-appropriate colors
            let strokeColor; 
            if (hostStatus === 'online') {
                if (i % 3 === 0) strokeColor = '#4ade80'; // Light green
                else if (i % 3 === 1) strokeColor = '#22c55e'; // Medium green
                else strokeColor = '#16a34a'; // Dark green
            } else if (hostStatus === 'offline') {
                if (i % 3 === 0) strokeColor = '#f87171'; // Light red
                else if (i % 3 === 1) strokeColor = '#ef4444'; // Medium red
                else strokeColor = '#dc2626'; // Dark red
            } else {
                if (i % 3 === 0) strokeColor = primaryColor;
                else if (i % 3 === 1) strokeColor = secondaryColor;
                else strokeColor = `rgba(${parseInt(primaryColor.slice(1, 3), 16)}, ${parseInt(primaryColor.slice(3, 5), 16)}, ${parseInt(primaryColor.slice(5, 7), 16)}, ${pathOpacity * 1.5})`;
            }
            
            path.setAttribute('stroke', strokeColor);
            // Thinner, more consistent lines for circuit look
            path.setAttribute('stroke-width', (pathWidth * 0.7).toFixed(1));
            // Start with opacity 0 for smooth fade-in
            path.setAttribute('opacity', '0');
            
            // Add animation attributes
            // Use fixed length for stroke dash to create shorter, more dynamic lines
            path.style.strokeDasharray = `${fixedLength}`;
            path.style.strokeDashoffset = `${fixedLength}`;
            
            // Use more consistent animation approach for all paths
            // First create the animations
            const fadeInAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            fadeInAnimation.setAttribute('attributeName', 'opacity');
            fadeInAnimation.setAttribute('from', '0');
            fadeInAnimation.setAttribute('to', pathOpacity.toString());
            fadeInAnimation.setAttribute('dur', '1.5s');
            fadeInAnimation.setAttribute('begin', `${delay}s`);
            fadeInAnimation.setAttribute('fill', 'freeze');
            
            const strokeAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            strokeAnimation.setAttribute('attributeName', 'stroke-dashoffset');
            strokeAnimation.setAttribute('from', fixedLength.toString());
            strokeAnimation.setAttribute('to', '0');
            strokeAnimation.setAttribute('dur', `${duration * 0.6}s`); // Even faster to create quicker movement
            strokeAnimation.setAttribute('begin', `${delay}s`);
            // Make it restart after fadeOut ends
            strokeAnimation.setAttribute('repeatCount', 'indefinite');
            // Add ID for targeting
            strokeAnimation.setAttribute('id', `stroke-anim-${i}`);
            
            // Create quick fade-out that happens soon after the line appears
            // This creates the effect of lines quickly disappearing after some movement
            const quickFadeOut = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            quickFadeOut.setAttribute('attributeName', 'opacity');
            quickFadeOut.setAttribute('from', pathOpacity.toString());
            quickFadeOut.setAttribute('to', '0');
            quickFadeOut.setAttribute('dur', '0.8s');
            // Start fade-out after line has traveled a bit of distance (30% of animation)
            quickFadeOut.setAttribute('begin', `${delay + duration * 0.3}s; ${delay + duration * 1.3}s; ${delay + duration * 2.3}s;`);
            quickFadeOut.setAttribute('fill', 'freeze');
            
            // Quick fade-in to restart the cycle
            const cycleFadeInAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            cycleFadeInAnimation.setAttribute('attributeName', 'opacity');
            cycleFadeInAnimation.setAttribute('from', '0');
            cycleFadeInAnimation.setAttribute('to', pathOpacity.toString());
            cycleFadeInAnimation.setAttribute('dur', '0.5s');
            // Start after each fade-out completes
            cycleFadeInAnimation.setAttribute('begin', `${delay + duration * 0.9}s; ${delay + duration * 1.9}s; ${delay + duration * 2.9}s;`);
            cycleFadeInAnimation.setAttribute('fill', 'freeze');
            
            // Add all the animations to the path
            path.appendChild(fadeInAnimation);
            path.appendChild(strokeAnimation);
            path.appendChild(quickFadeOut);
            path.appendChild(cycleFadeInAnimation);
            
            svg.appendChild(path);
            
            // Add circuit nodes
            if (i % 3 < 2) { // Add nodes to more paths for better coverage
                // Extract coordinates of path turning points
                const matches = d.match(/M(-?\d+),(-?\d+)/g);
                if (matches) {
                    matches.forEach((match, index) => {
                        // Skip some points randomly
                        if (index % 2 === 0 && i % 2 === 0) return; // Skip fewer points
                        
                        const coords = match.match(/M(-?\d+),(-?\d+)/);
                        if (coords && coords.length >= 3) {
                            const cx = parseInt(coords[1]);
                            const cy = parseInt(coords[2]);
                            
                            // Create a small circle at the turning point
                            const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            node.setAttribute('cx', cx);
                            node.setAttribute('cy', cy);
                            node.setAttribute('r', 2 + (i % 3)); // Varied node sizes
                            node.setAttribute('fill', strokeColor);
                            node.setAttribute('opacity', '0');
                            
                            // Add fade in animation
                            const nodeFadeIn = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            nodeFadeIn.setAttribute('attributeName', 'opacity');
                            nodeFadeIn.setAttribute('from', '0');
                            nodeFadeIn.setAttribute('to', (pathOpacity * 1.3).toString());
                            nodeFadeIn.setAttribute('dur', '0.3s');
                            nodeFadeIn.setAttribute('begin', `${delay + 0.1}s; ${delay + duration * 1.1}s; ${delay + duration * 2.1}s;`);
                            nodeFadeIn.setAttribute('fill', 'freeze');
                            
                            // Add fade out animation
                            const nodeFadeOut = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            nodeFadeOut.setAttribute('attributeName', 'opacity');
                            nodeFadeOut.setAttribute('from', (pathOpacity * 1.3).toString());
                            nodeFadeOut.setAttribute('to', '0');
                            nodeFadeOut.setAttribute('dur', '0.5s');
                            nodeFadeOut.setAttribute('begin', `${delay + duration * 0.3}s; ${delay + duration * 1.3}s; ${delay + duration * 2.3}s;`);
                            nodeFadeOut.setAttribute('fill', 'freeze');
                            
                            // Add animations to node
                            node.appendChild(nodeFadeIn);
                            node.appendChild(nodeFadeOut);
                            
                            // Add node to SVG
                            svg.appendChild(node);
                        }
                    });
                }
            }
        }
    }
    
    // Generate paths initially
    generateAnimatedPaths();
    
    // Regenerate on status change
    const statusObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-status') {
                generateAnimatedPaths();
            }
        });
    });
    
    const wakeBtn = document.querySelector('#wakeHostBtn');
    if (wakeBtn) {
        statusObserver.observe(wakeBtn, { attributes: true });
    }
    
    // Regenerate on resize for responsiveness
    window.addEventListener('resize', debounce(generateAnimatedPaths, 250));
    
    // Helper function for debouncing
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(function() {
                func.apply(context, args);
            }, wait);
        };
    }

    // Function to show the wake animation
    function showWakeAnimation() {
        const overlay = document.getElementById('wakeAnimationOverlay');
        if (overlay) {
            overlay.classList.add('active');
            
            // Setup close button
            const closeButton = document.getElementById('wakeCloseButton');
            if (closeButton) {
                closeButton.addEventListener('click', function() {
                    overlay.classList.remove('active');
                    resetWakeAnimation();
                });
            }
            
            // Start the progress bar animation
            const progressBar = document.querySelector('.wake-progress-bar');
            if (progressBar) {
                progressBar.style.width = '0%';
                setTimeout(() => {
                    // Make the progress bar fill over 60 seconds to match the status check timeout
                    progressBar.style.width = '100%';
                    progressBar.style.transition = 'width 60s linear';
                }, 100);
            }
            
            // Submit the wake request via AJAX to prevent page refresh
            setTimeout(() => {
                // Get form data
                const formData = new FormData(wakeHostForm);
                const hostId = formData.get('host_id');
                const csrfToken = formData.get('csrf_token');
                
                // Make AJAX request instead of form submission
                fetch(wakeHostForm.action, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    console.log('Wake request sent successfully');
                    // Start polling for status changes
                    startStatusPolling();
                })
                .catch(error => {
                    console.error('Error sending wake request:', error);
                    // Still start polling in case the packet was sent despite the error
                    startStatusPolling();
                });
            }, 1000);
        }
    }

    // Function to poll the host status after wake command
    function startStatusPolling() {
        const overlay = document.getElementById('wakeAnimationOverlay');
        const hostId = document.querySelector('#wakeHostBtn').getAttribute('data-host-id');
        const statusText = document.querySelector('.wake-text-status');
        let attempts = 0;
        const maxAttempts = 12; // Check for about 60 seconds (12 attempts, 5 seconds each)
        
        // Extract the token from the current URL
        const pathSegments = window.location.pathname.split('/');
        const token = pathSegments[pathSegments.length - 1];
        
        console.log('Starting status polling for host:', hostId);
        
        // Start polling
        const statusInterval = setInterval(() => {
            console.log('Polling attempt:', attempts + 1);
            
            // Update status text with attempts count
            if (statusText) {
                const timeRemaining = (maxAttempts - attempts) * 5;
                statusText.textContent = `Checking host status... ${timeRemaining}s remaining`;
            }
            
            // Fetch the current status
            fetch(`/public/host/${token}/status`)
                .then(response => response.json())
                .then(data => {
                    console.log('Status response:', data);
                    attempts++;
                    
                    // If host is online, show success and stop polling
                    if (data.status === 'online') {
                        console.log('Host is online, showing success');
                        clearInterval(statusInterval);
                        showWakeResult('success');
                        
                        // Update the page's status indicator without refreshing
                        const statusBadge = document.querySelector(`#host-${data.host_id}-status`);
                        if (statusBadge) {
                            statusBadge.setAttribute('data-status', 'online');
                            statusBadge.classList.remove('bg-danger', 'bg-secondary');
                            statusBadge.classList.add('bg-success');
                            statusBadge.innerHTML = '<i class="fas fa-circle-check fa-xs me-1"></i>online';
                        }
                        
                        // Update wake button status
                        const wakeButton = document.querySelector('#wakeHostBtn');
                        if (wakeButton) {
                            wakeButton.classList.remove('offline', 'unknown');
                            wakeButton.classList.add('online');
                            wakeButton.setAttribute('data-status', 'online');
                        }
                        
                        // Regenerate animation background based on new status
                        if (typeof generateAnimatedPaths === 'function') {
                            setTimeout(generateAnimatedPaths, 1000);
                        }
                        
                        // Keep the success message visible for 3 seconds before hiding
                        setTimeout(() => {
                            overlay.classList.remove('active');
                            resetWakeAnimation();
                        }, 3000);
                    }
                    
                    // If max attempts reached, show failure
                    if (attempts >= maxAttempts && data.status !== 'online') {
                        console.log('Max attempts reached, showing failure');
                        clearInterval(statusInterval);
                        showWakeResult('failure');
                    }
                })
                .catch(error => {
                    console.error('Error checking host status:', error);
                    attempts++;
                    
                    // If max attempts reached, show failure
                    if (attempts >= maxAttempts) {
                        clearInterval(statusInterval);
                        showWakeResult('failure');
                    }
                });
        }, 5000); // Check every 5 seconds
        
        // Safety timeout to prevent infinite checking
        setTimeout(() => {
            console.log('Safety timeout reached');
            clearInterval(statusInterval);
            // If overlay is still active, show failure
            if (overlay.classList.contains('active')) {
                showWakeResult('failure');
            }
        }, 62000); // Stop after 62 seconds (slightly more than maxAttempts * polling interval)
    }

    // Function to show success or failure result
    function showWakeResult(result) {
        console.log('Showing wake result:', result);
        const overlay = document.getElementById('wakeAnimationOverlay');
        const successElement = document.querySelector('.wake-result.success');
        const failureElement = document.querySelector('.wake-result.failure');
        const waves = document.querySelectorAll('.wave');
        const packets = document.querySelectorAll('.packet');
        const progressContainer = document.querySelector('.wake-progress-container');
        const statusText = document.querySelector('.wake-text-status');
        const title = document.querySelector('.wake-text-title');
        const subtitle = document.querySelector('.wake-text-subtitle');
        
        // Hide status elements
        if (statusText) statusText.style.display = 'none';
        if (progressContainer) progressContainer.style.display = 'none';
        if (title) title.style.opacity = '0.5';
        if (subtitle) subtitle.style.opacity = '0.5';
        
        // Stop animations
        waves.forEach(wave => {
            wave.style.animationPlayState = 'paused';
            wave.style.opacity = '0.2';
        });
        
        packets.forEach(packet => {
            packet.style.animationPlayState = 'paused';
            packet.style.opacity = '0';
        });
        
        // Show appropriate result
        if (result === 'success') {
            if (successElement) {
                successElement.style.display = 'flex';
                // Add success animations
                document.querySelector('.pulse-circle').classList.add('success-pulse');
            }
        } else {
            if (failureElement) {
                failureElement.style.display = 'flex';
                // Add failure animations
                document.querySelector('.pulse-circle').classList.add('failure-pulse');
                
                // Setup retry button
                const retryButton = document.querySelector('.wake-retry-button');
                if (retryButton) {
                    // Remove any existing event listeners to prevent duplicates
                    const newRetryButton = retryButton.cloneNode(true);
                    retryButton.parentNode.replaceChild(newRetryButton, retryButton);
                    
                    newRetryButton.addEventListener('click', () => {
                        resetWakeAnimation();
                        overlay.classList.remove('active');
                        setTimeout(() => {
                            showWakeAnimation();
                        }, 500);
                    });
                }
            }
        }
    }

    // Function to reset the wake animation state
    function resetWakeAnimation() {
        const successElement = document.querySelector('.wake-result.success');
        const failureElement = document.querySelector('.wake-result.failure');
        const statusText = document.querySelector('.wake-text-status');
        const progressContainer = document.querySelector('.wake-progress-container');
        const title = document.querySelector('.wake-text-title');
        const subtitle = document.querySelector('.wake-text-subtitle');
        const pulseCircle = document.querySelector('.pulse-circle');
        
        // Reset elements
        if (successElement) successElement.style.display = 'none';
        if (failureElement) failureElement.style.display = 'none';
        if (statusText) {
            statusText.style.display = 'block';
            statusText.textContent = 'Waiting for response...';
        }
        if (progressContainer) progressContainer.style.display = 'block';
        if (title) title.style.opacity = '1';
        if (subtitle) subtitle.style.opacity = '1';
        
        // Reset animations
        if (pulseCircle) {
            pulseCircle.classList.remove('success-pulse', 'failure-pulse');
        }
        
        // Reset wave and packet animations
        document.querySelectorAll('.wave, .packet').forEach(el => {
            el.style.animationPlayState = '';
            el.style.opacity = '';
        });
    }

    // Optional: Hide the animation if the form submission takes too long
    // This is a safety measure in case something goes wrong
    setTimeout(() => {
        const overlay = document.getElementById('wakeAnimationOverlay');
        if (overlay && overlay.classList.contains('active')) {
            setTimeout(() => {
                overlay.classList.remove('active');
            }, 70000); // Safety timeout after 70 seconds (more than the 60s check)
        }
    }, 70000);
});
</script>

<style>
/* Public host page custom styles */
.host-card {
    overflow: hidden;
    border-radius: 1rem;
    transform: translateY(30px);
    opacity: 0;
    position: relative;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.85);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1), 0 5px 10px rgba(0, 0, 0, 0.05);
    transition: all 0.3s var(--animation-spring);
}

.host-card:hover {
    transform: translateY(0) scale(1.02) !important;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15), 0 10px 15px rgba(0, 0, 0, 0.07);
}

/* Animated background */
.animated-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 1rem;
    z-index: 0;
    opacity: 0.9; /* Increased opacity for more visibility */
    transition: opacity 0.5s ease;
}

.animated-paths {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    filter: blur(0.5px); /* Slight blur for a glowing effect */
    transform: translateZ(0); /* Force hardware acceleration */
    overflow: visible !important; /* Allow paths to go outside the SVG for smoother animations */
}

/* Updated SVG positioning to ensure it fills the entire background */
.animated-paths svg {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}

/* Make card content appear above the animated background */
.card-header, .card-body, .card-footer {
    position: relative;
    z-index: 1;
    background-color: transparent !important;
}

.card-header {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color)) !important;
    border-radius: 1rem 1rem 0 0 !important;
}

.card-footer {
    background: rgba(0, 0, 0, 0.03) !important;
    backdrop-filter: blur(5px);
    border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 0 0 1rem 1rem !important;
}

.bg-gradient-primary {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
}

.icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 10px;
    color: white;
    transition: all 0.3s ease;
}

.icon-mac {
    background-color: var(--primary-color);
    box-shadow: 0 4px 8px rgba(var(--primary-color-rgb), 0.2);
}

.icon-info {
    background-color: var(--accent-color);
    box-shadow: 0 4px 8px rgba(var(--accent-color-rgb), 0.2);
}

.icon-time {
    background-color: var(--secondary-color);
    box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
}

.dark-theme .icon-container {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.mac-address {
    font-family: monospace;
    letter-spacing: 0.5px;
}

.status-indicator {
    display: none;
}

.status-circle {
    display: none;
}

.wake-button {
    display: none;
}

/* Merged wake button with status indicator */
.wake-button-container {
    margin: 20px 0;
    position: relative;
}

.wake-button-circle {
    width: 180px;
    height: 180px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    border: none;
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    color: white;
    transition: all 0.3s ease;
    cursor: pointer;
    padding: 0;
    overflow: hidden;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}

.wake-button-circle::before {
    content: '';
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    bottom: 8px;
    border-radius: 50%;
    border: 4px solid rgba(255, 255, 255, 0.3);
    z-index: 1;
}

.wake-button-circle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 75%;
    height: 75%;
    border-radius: 50%;
    z-index: 0;
    opacity: 0.15;
    transition: all 0.5s ease;
}

.button-inner {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    text-align: center;
}

.power-icon {
    font-size: 2.5rem;
    margin-bottom: 10px;
    transition: all 0.3s ease;
}

.button-text {
    font-weight: 600;
    font-size: 1.1rem;
    letter-spacing: 0.5px;
}

/* Status variations */
.wake-button-circle.online {
    background: linear-gradient(135deg, var(--success-color), #50c878);
    box-shadow: 0 5px 20px rgba(40, 167, 69, 0.4);
}

.wake-button-circle.online::after {
    background-color: var(--success-color);
    animation: wake-button-pulse 2s infinite ease-in-out;
}

.wake-button-circle.offline {
    background: linear-gradient(135deg, var(--danger-color), #ff5757);
    box-shadow: 0 5px 20px rgba(220, 53, 69, 0.4);
}

.wake-button-circle.offline::after {
    background-color: var(--danger-color);
    animation: wake-button-pulse 2s infinite ease-in-out;
}

.wake-button-circle.unknown {
    background: linear-gradient(135deg, var(--secondary-color), #8d98a3);
    box-shadow: 0 5px 20px rgba(108, 117, 125, 0.4);
}

.wake-button-circle.unknown::after {
    background-color: var(--secondary-color);
}

.wake-button-circle:hover {
    transform: translateY(-5px) scale(1.03);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
}

.wake-button-circle:active {
    transform: translateY(2px) scale(0.98);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.wake-button-circle:hover .power-icon {
    transform: scale(1.2);
}

@keyframes wake-button-pulse {
    0% {
        opacity: 0.1;
        transform: translate(-50%, -50%) scale(0.9);
    }
    50% {
        opacity: 0.2;
        transform: translate(-50%, -50%) scale(1.05);
    }
    100% {
        opacity: 0.1;
        transform: translate(-50%, -50%) scale(0.9);
    }
}

/* Enhanced card entrance animation */
@keyframes cardEntrance {
    0% {
        opacity: 0;
        transform: translateY(50px) scale(0.9);
        filter: blur(10px);
    }
    50% {
        opacity: 1;
        filter: blur(0);
    }
    75% {
        transform: translateY(-10px) scale(1.02);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Dark theme adjustments */
.dark-theme .host-card {
    background-color: rgba(30, 30, 40, 0.85);
    border-color: rgba(255, 255, 255, 0.1);
}

.dark-theme .card-footer {
    background-color: rgba(0, 0, 0, 0.2) !important;
    border-top-color: rgba(255, 255, 255, 0.1) !important;
}

.dark-theme .animated-background {
    opacity: 0.35; /* Increased opacity for dark theme */
}

/* Glowing effect for the wake button in dark mode */
.dark-theme .wake-button-circle {
    box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.5);
}

.dark-theme .wake-button-circle.online {
    box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
}

.dark-theme .wake-button-circle.offline {
    box-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
}

/* Mobile optimizations */
@media (max-width: 768px) {
    .wake-button-circle {
        width: 150px;
        height: 150px;
    }
    
    .power-icon {
        font-size: 2rem;
    }
    
    .button-text {
        font-size: 1rem;
    }
}

@media (max-width: 576px) {
    .host-card {
        border-radius: 0.75rem;
    }
    
    .card-header {
        border-radius: 0.75rem 0.75rem 0 0 !important;
    }
    
    .card-footer {
        border-radius: 0 0 0.75rem 0.75rem !important;
    }
}

/* Wake Animation Overlay */
.wake-animation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    overflow: hidden;
    backdrop-filter: blur(5px);
}

/* Close button */
.wake-close-button {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10;
    transition: all 0.2s ease;
}

.wake-close-button:hover {
    background-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.wake-close-button:active {
    transform: scale(0.95);
}

.wake-close-button i {
    opacity: 0.8;
}

.wake-animation-overlay.active {
    opacity: 1;
    visibility: visible;
}

.wake-animation-container {
    position: relative;
    width: 100%;
    max-width: 500px;
    height: auto;
    min-height: 500px;
    display: flex;
    align-items: stretch;
    justify-content: space-between;
    flex-direction: column;
    padding: 40px 20px;
}

/* Animation area - contains all animated elements */
.animation-area {
    position: absolute;
    top: 60px;
    left: 0;
    right: 0;
    height: 280px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Pulsing signal waves */
.signal-waves {
    position: absolute;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
}

.wave {
    position: absolute;
    border-radius: 50%;
    border: 2px solid transparent;
    opacity: 0;
    transform: scale(0);
}

.wake-animation-overlay.active .wave {
    animation: waveAnimation 3s infinite ease-out;
}

.wave1 {
    width: 60px;
    height: 60px;
    border-color: var(--primary-color);
    animation-delay: 0s !important;
}

.wave2 {
    width: 120px;
    height: 120px;
    border-color: var(--accent-color);
    animation-delay: 0.4s !important;
}

.wave3 {
    width: 180px;
    height: 180px;
    border-color: var(--primary-color);
    animation-delay: 0.8s !important;
}

.wave4 {
    width: 240px;
    height: 240px;
    border-color: var(--accent-color);
    animation-delay: 1.2s !important;
}

/* Center pulse circle - now directly in animation area */
.pulse-circle {
    position: absolute;
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    border-radius: 50%;
    z-index: 2;
    box-shadow: 0 0 30px var(--primary-color);
}

.wake-animation-overlay.active .pulse-circle {
    animation: pulseCircle 1.5s infinite alternate;
}

/* Flying packets animation */
.packet-container {
    position: relative;
    width: 100%;
    height: 100%;
    z-index: 3;
}

.packet {
    position: absolute;
    width: 15px;
    height: 15px;
    background-color: white;
    border-radius: 50%;
    opacity: 0;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
}

.wake-animation-overlay.active .packet {
    animation: packetFly 2s infinite linear;
}

.packet1 {
    top: 50%;
    left: 50%;
    animation-delay: 0.2s !important;
}

.packet2 {
    top: 50%;
    left: 50%;
    animation-delay: 0.8s !important;
}

.packet3 {
    top: 50%;
    left: 50%;
    animation-delay: 1.4s !important;
}

/* Wake text */
.wake-text {
    position: absolute;
    bottom: 40px;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    width: 100%;
    z-index: 5; /* Ensure text is above all other elements */
    padding: 0 20px;
}

.wake-text-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
    opacity: 0;
    transform: translateY(20px);
}

.wake-text-subtitle {
    font-size: 16px;
    margin-bottom: 15px;
    opacity: 0;
    transform: translateY(20px);
}

.wake-text-status {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 10px;
}

.wake-animation-overlay.active .wake-text-title {
    animation: fadeInUp 0.5s forwards;
}

.wake-animation-overlay.active .wake-text-subtitle {
    animation: fadeInUp 0.5s 0.2s forwards;
}

.wake-animation-overlay.active .wake-text-status {
    animation: fadeInUp 0.5s 0.3s forwards;
}

/* Success and failure states */
.wake-result {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-top: 15px;
    animation: fadeInUp 0.5s forwards;
    position: relative;
    z-index: 6; /* Ensure result content is above all elements */
}

.wake-icon-success, .wake-icon-failure {
    font-size: 40px;
    margin-bottom: 10px;
}

.wake-icon-success {
    color: #4ade80; /* Success green */
}

.wake-icon-failure {
    color: #f87171; /* Failure red */
}

.wake-result-text {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 10px;
}

.wake-retry-button {
    padding: 8px 20px;
    background: linear-gradient(135deg, #f87171, #ef4444);
    color: white;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    margin-top: 10px;
    transition: all 0.2s ease;
    box-shadow: 0 3px 10px rgba(239, 68, 68, 0.3);
}

.wake-retry-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
}

.wake-retry-button:active {
    transform: translateY(1px);
}

/* Success and failure pulse animations */
.pulse-circle.success-pulse {
    background: linear-gradient(135deg, #4ade80, #22c55e);
    box-shadow: 0 0 30px #22c55e;
    animation: successPulse 1.5s infinite alternate;
}

.pulse-circle.failure-pulse {
    background: linear-gradient(135deg, #f87171, #ef4444);
    box-shadow: 0 0 30px #ef4444;
    animation: failurePulse 1.5s infinite alternate;
}

@keyframes successPulse {
    0% {
        transform: scale(0.95);
        box-shadow: 0 0 20px #22c55e;
    }
    100% {
        transform: scale(1.05);
        box-shadow: 0 0 40px #22c55e;
    }
}

@keyframes failurePulse {
    0% {
        transform: scale(0.95);
        box-shadow: 0 0 20px #ef4444;
    }
    100% {
        transform: scale(1.05);
        box-shadow: 0 0 40px #ef4444;
    }
}

/* Progress bar */
.wake-progress-container {
    width: 100%;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    overflow: hidden;
    margin-top: 10px;
}

.wake-progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(to right, var(--primary-color), var(--accent-color));
    border-radius: 3px;
    transition: width 0.3s ease; /* Initial transition is quick, then modified to 60s in JS */
}

/* Animation keyframes */
@keyframes waveAnimation {
    0% {
        opacity: 0.8;
        transform: scale(0);
    }
    70% {
        opacity: 0.2;
    }
    100% {
        opacity: 0;
        transform: scale(1);
    }
}

@keyframes pulseCircle {
    0% {
        transform: scale(0.95);
        box-shadow: 0 0 20px var(--primary-color);
    }
    100% {
        transform: scale(1.05);
        box-shadow: 0 0 40px var(--primary-color);
    }
}

@keyframes packetFly {
    0% {
        transform: translate(0, 0) scale(0.5);
        opacity: 0;
    }
    10% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: translate(calc(cos(var(--angle, 0deg)) * 150px), calc(sin(var(--angle, 90deg)) * 150px)) scale(0.5);
        opacity: 0;
    }
}

.packet1 {
    --angle: 45deg;
}

.packet2 {
    --angle: 180deg;
}

.packet3 {
    --angle: 300deg;
}

@keyframes fadeInUp {
    0% {
        opacity: 0;
        transform: translateY(20px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Dark theme adjustments for the wake animation */
.dark-theme .wake-animation-overlay {
    background-color: rgba(0, 0, 0, 0.9);
}

/* Mobile optimizations for wake animation */
@media (max-width: 576px) {
    .wake-animation-container {
        width: 100%;
        max-width: 320px;
        min-height: 450px;
        padding: 30px 15px;
    }
    
    .animation-area {
        height: 240px;
        top: 50px;
    }
    
    .wave4 {
        width: 200px;
        height: 200px;
    }
    
    .wake-text {
        bottom: 30px;
    }
    
    .wake-text-title {
        font-size: 20px;
    }
}

/* Animation for users who prefer reduced motion */
@media (prefers-reduced-motion) {
    .wake-animation-overlay {
        display: none;
    }
}
</style>
{% endblock %}
