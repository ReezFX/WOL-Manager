{% extends "base.html" %}

{% block title %}{{ host.name }} - Public View{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card host-card shadow-lg border-0">
                <!-- Animated background -->
                <div class="animated-background">
                    <svg class="animated-paths" viewBox="-400 -250 800 500" preserveAspectRatio="xMidYMid slice">
                        <!-- SVG paths will be generated by JavaScript -->
                    </svg>
                </div>
                <!-- Card content -->
                <div class="card-header d-flex justify-content-between align-items-center bg-gradient-primary text-white py-3">
                    <h4 class="card-title mb-0 fw-bold">
                        <i class="fas fa-server me-2"></i>{{ host.name }}
                    </h4>
                    {% if host.status == 'online' %}
                        <span class="badge bg-success status-badge" id="host-{{ host.id }}-status" data-status="online">
                            <i class="fas fa-circle-check fa-xs me-1"></i>online
                        </span>
                    {% elif host.status == 'offline' %}
                        <span class="badge bg-danger status-badge" id="host-{{ host.id }}-status" data-status="offline">
                            <i class="fas fa-circle-xmark fa-xs me-1"></i>offline
                        </span>
                    {% else %}
                        <span class="badge bg-secondary status-badge" id="host-{{ host.id }}-status" data-status="unknown">
                            <i class="fas fa-circle-question fa-xs me-1"></i>unknown
                        </span>
                    {% endif %}
                </div>
                <div class="card-body p-4">
                    <div class="host-info mb-4">
                        <div class="row align-items-center">
                            <div class="col-md-6">
                                <div class="info-item mb-3">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-mac">
                                            <i class="fas fa-network-wired"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">MAC Address</h6>
                                            <p class="mb-0 mac-address fw-bold">{{ host.mac_address }}</p>
                                        </div>
                                    </div>
                                </div>
                                
                                {% if host.description %}
                                <div class="info-item mb-3">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-info">
                                            <i class="fas fa-info-circle"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">Description</h6>
                                            <p class="mb-0">{{ host.description }}</p>
                                        </div>
                                    </div>
                                </div>
                                {% endif %}
                                
                                <div class="info-item">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-container me-3 icon-time">
                                            <i class="fas fa-clock"></i>
                                        </div>
                                        <div>
                                            <h6 class="mb-0 text-muted fw-semibold">Last Check</h6>
                                            <p class="mb-0" id="host-{{ host.id }}-last-check">
                                                Checking status...
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6 d-flex flex-column align-items-center justify-content-center mt-4 mt-md-0">
                                <form method="post" action="{{ url_for('public.wake_host') }}" id="wakeHostForm" class="text-center">
                                    <input type="hidden" name="host_id" value="{{ host.id }}">
                                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                                    <div class="wake-button-container">
                                        <button type="button" id="wakeHostBtn" 
                                            class="wake-button-circle btn-animate-press {% if host.status == 'online' %}online{% elif host.status == 'offline' %}offline{% else %}unknown{% endif %}"
                                            data-status="{{ host.status }}" data-host-id="{{ host.id }}">
                                            <div class="button-inner">
                                                <i class="fas fa-power-off power-icon"></i>
                                                <span class="button-text">Wake Host</span>
                                            </div>
                                        </button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-footer bg-light py-3 text-center">
                    <small class="text-muted">Powered by WOL Manager</small>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function() {
    function updateHostStatuses() {
        // Extract the token from the current URL
        const pathSegments = window.location.pathname.split('/');
        const token = pathSegments[pathSegments.length - 1];
        
        fetch(`/public/host/${token}/status`)
            .then(response => response.json())
            .then(data => {
                const statusBadge = document.querySelector(`#host-${data.host_id}-status`);
                const wakeButton = document.querySelector('#wakeHostBtn');
                
                if (statusBadge) {
                    // Update status badge with more obvious animations
                    if (typeof window.updateStatusBadgeAnimation === 'function') {
                        // Use the enhanced animation function if available
                        window.updateStatusBadgeAnimation(`host-${data.host_id}-status`, data.status);
                    } else {
                        // Fallback to basic update
                        statusBadge.setAttribute('data-status', data.status);
                        
                        // Update badge background classes
                        statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-secondary');
                        if (data.status === 'online') {
                            statusBadge.classList.add('bg-success');
                        } else if (data.status === 'offline') {
                            statusBadge.classList.add('bg-danger');
                        } else {
                            statusBadge.classList.add('bg-secondary');
                        }
                        
                        // Update icon and text
                        let icon = '<i class="fas fa-circle-question fa-xs me-1"></i>';
                        if (data.status === 'online') {
                            icon = '<i class="fas fa-circle-check fa-xs me-1"></i>';
                        } else if (data.status === 'offline') {
                            icon = '<i class="fas fa-circle-xmark fa-xs me-1"></i>';
                        }
                        statusBadge.innerHTML = icon + data.status;
                    }
                    
                    // Update wake button status
                    if (wakeButton) {
                        wakeButton.classList.remove('online', 'offline', 'unknown');
                        wakeButton.classList.add(data.status);
                        wakeButton.setAttribute('data-status', data.status);
                    }
                    
                    // Update last check time
                    const lastCheck = document.querySelector(`#host-${data.host_id}-last-check`);
                    if (lastCheck && data.last_check) {
                        const date = new Date(data.last_check);
                        lastCheck.textContent = date.toLocaleString();
                    }
                }
            })
            .catch(error => {
                console.error('Error updating host statuses:', error);
            });
    }

    // Add a subtle entrance animation to the card
    const hostCard = document.querySelector('.host-card');
    if (hostCard) {
        hostCard.style.animation = 'cardEntrance 0.6s var(--animation-spring) forwards';
    }

    // Update initially and then every 15 seconds
    updateHostStatuses();
    setInterval(updateHostStatuses, 15000);
    
    // Handle wake button click with confirmation dialog
    const wakeHostBtn = document.querySelector('#wakeHostBtn');
    const wakeHostForm = document.querySelector('#wakeHostForm');
    
    if (wakeHostBtn && wakeHostForm) {
        wakeHostBtn.addEventListener('click', function() {
            const status = this.getAttribute('data-status');
            
            if (status === 'online') {
                // Show confirmation dialog for online hosts
                if (confirm('This host appears to be online already. Do you still want to wake it?')) {
                    wakeHostForm.submit();
                }
            } else {
                // No confirmation needed for offline hosts
                wakeHostForm.submit();
            }
        });
    }
    
    // Generate animated SVG paths
    function generateAnimatedPaths() {
        const svg = document.querySelector('.animated-paths');
        if (!svg) return;
        
        // Clear existing paths
        svg.innerHTML = '';
        
        // Get host status to set color theme
        const wakeButton = document.querySelector('#wakeHostBtn');
        const hostStatus = wakeButton ? wakeButton.getAttribute('data-status') : 'unknown';
        
        // Set color variables based on host status
        let primaryColor, secondaryColor, opacity;
        
        if (hostStatus === 'online') {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim() || '#28a745';
            secondaryColor = '#50c878';
            opacity = 0.07;
        } else if (hostStatus === 'offline') {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim() || '#dc3545';
            secondaryColor = '#ff5757';
            opacity = 0.07;
        } else {
            primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#007bff';
            secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || '#6610f2';
            opacity = 0.07;
        }
        
        // Check for dark theme
        const isDarkTheme = document.body.classList.contains('dark-theme');
        if (isDarkTheme) {
            opacity = 0.12; // Higher opacity for dark theme for better visibility
        }
        
        // Generate paths (similar to the React example)
        const numberOfPaths = 42; // Increased number of paths for more intensity
        
        // Pre-calculate path parameters for symmetry
        const pathParams = [];
        
        // Fixed lengths for lines to make them shorter with quicker transitions
        const fixedLineLengths = [100, 150, 200, 250, 300]; // Shorter lengths for circuit paths
        
        // Create symmetrical starting points
        const xOffsets = [];
        const yOffsets = [];
        
        // Generate symmetric distribution of points
        for (let i = 0; i < numberOfPaths; i++) {
            // Create mirror patterns for x/y offsets
            const mirrorIndex = numberOfPaths - i - 1;
            const normalizedPos = i / (numberOfPaths - 1); // 0 to 1
            
            // Create a more spread out grid of starting points covering the entire background
            // Calculate positions using quadrant-based approach for better distribution
            const quadrant = i % 4; // 0: top-left, 1: top-right, 2: bottom-right, 3: bottom-left
            const posInQuadrant = Math.floor(i / 4) / Math.ceil(numberOfPaths / 4);
            
            if (quadrant === 0) {
                // Top-left quadrant
                xOffsets[i] = -380 + (posInQuadrant * 190);
                yOffsets[i] = -230 + (posInQuadrant * 115);
            } else if (quadrant === 1) {
                // Top-right quadrant
                xOffsets[i] = 0 + (posInQuadrant * 190);
                yOffsets[i] = -230 + (posInQuadrant * 115);
            } else if (quadrant === 2) {
                // Bottom-right quadrant
                xOffsets[i] = 0 + (posInQuadrant * 190);
                yOffsets[i] = 0 + (posInQuadrant * 115);
            } else {
                // Bottom-left quadrant
                xOffsets[i] = -380 + (posInQuadrant * 190);
                yOffsets[i] = 0 + (posInQuadrant * 115);
            }
            
            // Add slight randomization to prevent too much symmetry
            xOffsets[i] += (Math.random() * 40) - 20;
            yOffsets[i] += (Math.random() * 40) - 20;
        }
        
        for (let i = 0; i < numberOfPaths; i++) {
            // Calculate parameters with symmetry in mind
            const pathOpacity = opacity + (i * 0.01);
            const pathWidth = 0.6 + (i * 0.07);
            // Create symmetrical delay pattern
            const normalizedPos = i / (numberOfPaths - 1); // 0 to 1
            const delay = normalizedPos * 8; // Spread delays evenly across 8 seconds
            const duration = 15 + (i % 5) * 3; // More consistent durations
            const pathType = i % 5;
            
            // Store all params including the symmetric offsets
            pathParams.push({ 
                pathOpacity, 
                pathWidth, 
                delay, 
                duration: duration * 0.7, // Shorter overall duration for quicker animations
                pathType,
                xOffset: xOffsets[i] || 0,
                yOffset: yOffsets[i] || 0,
                // Assign a fixed line length to each path
                fixedLength: fixedLineLengths[i % fixedLineLengths.length]
            });
        }
        
        for (let i = 0; i < numberOfPaths; i++) {
            // Create random path data
            const { pathOpacity, pathWidth, delay, duration, pathType, xOffset, yOffset, fixedLength } = pathParams[i];
            
            // Create circuit-like paths with right angles instead of curves
            let d = '';
            
            // Helper function to create circuit paths with 90-degree angles
            const createCircuitPath = () => {
                // Start point
                let x = xOffset;
                let y = yOffset;
                
                // Define number of segments (turns) in the path
                const segments = 3 + (i % 4); // 3-6 segments for longer paths
                
                // Start the path
                d = `M${x},${y} `;
                
                // Create segments with right angles
                for (let s = 0; s < segments; s++) {
                    // More varied directions based on position to create paths that radiate outward
                    // This helps spread the animation across the background
                    let direction;
                    
                    if (x < -150 && y < -100) {
                        // Top-left: tend to go right and down
                        direction = [0, 1][s % 2];
                    } else if (x > 150 && y < -100) {
                        // Top-right: tend to go left and down
                        direction = [2, 1][s % 2];
                    } else if (x > 150 && y > 100) {
                        // Bottom-right: tend to go left and up
                        direction = [2, 3][s % 2];
                    } else if (x < -150 && y > 100) {
                        // Bottom-left: tend to go right and up
                        direction = [0, 3][s % 2];
                    } else if (Math.abs(x) < 150 && y < -100) {
                        // Top-center: tend to go down
                        direction = [0, 1, 2, 1][s % 4];
                    } else if (Math.abs(x) < 150 && y > 100) {
                        // Bottom-center: tend to go up
                        direction = [0, 3, 2, 3][s % 4];
                    } else if (x < -150 && Math.abs(y) < 100) {
                        // Left-center: tend to go right
                        direction = [0, 1, 0, 3][s % 4];
                    } else if (x > 150 && Math.abs(y) < 100) {
                        // Right-center: tend to go left
                        direction = [2, 1, 2, 3][s % 4];
                    } else {
                        // Center: random
                        direction = s % 4;
                    }
                    
                    // Calculate length of this segment (shorter near edges)
                    let segmentLength = 50 + (i % 7) * 20; // Longer segments to reach further
                    
                    // Cap length if getting too close to edges
                    if (direction === 0 && x > 350) segmentLength = 30; // Right edge
                    if (direction === 1 && y > 220) segmentLength = 30; // Bottom edge
                    if (direction === 2 && x < -350) segmentLength = 30; // Left edge
                    if (direction === 3 && y < -220) segmentLength = 30; // Top edge
                    
                    // Create right-angled segments
                    if (direction === 0) { // Horizontal right
                        x += segmentLength;
                        d += `h${segmentLength} `;
                    } else if (direction === 1) { // Vertical down
                        y += segmentLength;
                        d += `v${segmentLength} `;
                    } else if (direction === 2) { // Horizontal left
                        x -= segmentLength;
                        d += `h-${segmentLength} `;
                    } else { // Vertical up
                        y -= segmentLength;
                        d += `v-${segmentLength} `;
                    }
                    
                    // Add a circle node at each turn (except the last one)
                    if (s < segments - 1) {
                        d += `M${x},${y} `;
                    }
                }
                
                return d;
            };
            
            // Create circuit paths with different patterns
            if (pathType === 0) {
                // Horizontal dominant circuit
                d = createCircuitPath();
            } else if (pathType === 1) {
                // Vertical dominant circuit
                d = createCircuitPath();
            } else if (pathType === 2) {
                // Diagonal-like circuit with many turns
                d = createCircuitPath();
            } else if (pathType === 3) {
                // Long horizontal with small vertical jigs
                d = createCircuitPath();
            } else {
                // Complex circuit with multiple branches
                d = createCircuitPath();
            }
            
            // Create the SVG path element
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', d);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'square');  // Sharp corners for circuit look
            path.setAttribute('stroke-linejoin', 'miter');  // Sharp joins for circuit look
            
            // Circuit-appropriate colors
            let strokeColor; 
            if (hostStatus === 'online') {
                if (i % 3 === 0) strokeColor = '#4ade80'; // Light green
                else if (i % 3 === 1) strokeColor = '#22c55e'; // Medium green
                else strokeColor = '#16a34a'; // Dark green
            } else if (hostStatus === 'offline') {
                if (i % 3 === 0) strokeColor = '#f87171'; // Light red
                else if (i % 3 === 1) strokeColor = '#ef4444'; // Medium red
                else strokeColor = '#dc2626'; // Dark red
            } else {
                if (i % 3 === 0) strokeColor = primaryColor;
                else if (i % 3 === 1) strokeColor = secondaryColor;
                else strokeColor = `rgba(${parseInt(primaryColor.slice(1, 3), 16)}, ${parseInt(primaryColor.slice(3, 5), 16)}, ${parseInt(primaryColor.slice(5, 7), 16)}, ${pathOpacity * 1.5})`;
            }
            
            path.setAttribute('stroke', strokeColor);
            // Thinner, more consistent lines for circuit look
            path.setAttribute('stroke-width', (pathWidth * 0.7).toFixed(1));
            // Start with opacity 0 for smooth fade-in
            path.setAttribute('opacity', '0');
            
            // Add animation attributes
            // Use fixed length for stroke dash to create shorter, more dynamic lines
            path.style.strokeDasharray = `${fixedLength}`;
            path.style.strokeDashoffset = `${fixedLength}`;
            
            // Use more consistent animation approach for all paths
            // First create the animations
            const fadeInAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            fadeInAnimation.setAttribute('attributeName', 'opacity');
            fadeInAnimation.setAttribute('from', '0');
            fadeInAnimation.setAttribute('to', pathOpacity.toString());
            fadeInAnimation.setAttribute('dur', '1.5s');
            fadeInAnimation.setAttribute('begin', `${delay}s`);
            fadeInAnimation.setAttribute('fill', 'freeze');
            
            const strokeAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            strokeAnimation.setAttribute('attributeName', 'stroke-dashoffset');
            strokeAnimation.setAttribute('from', fixedLength.toString());
            strokeAnimation.setAttribute('to', '0');
            strokeAnimation.setAttribute('dur', `${duration * 0.6}s`); // Even faster to create quicker movement
            strokeAnimation.setAttribute('begin', `${delay}s`);
            // Make it restart after fadeOut ends
            strokeAnimation.setAttribute('repeatCount', 'indefinite');
            // Add ID for targeting
            strokeAnimation.setAttribute('id', `stroke-anim-${i}`);
            
            // Create quick fade-out that happens soon after the line appears
            // This creates the effect of lines quickly disappearing after some movement
            const quickFadeOut = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            quickFadeOut.setAttribute('attributeName', 'opacity');
            quickFadeOut.setAttribute('from', pathOpacity.toString());
            quickFadeOut.setAttribute('to', '0');
            quickFadeOut.setAttribute('dur', '0.8s');
            // Start fade-out after line has traveled a bit of distance (30% of animation)
            quickFadeOut.setAttribute('begin', `${delay + duration * 0.3}s; ${delay + duration * 1.3}s; ${delay + duration * 2.3}s;`);
            quickFadeOut.setAttribute('fill', 'freeze');
            
            // Quick fade-in to restart the cycle
            const cycleFadeInAnimation = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
            cycleFadeInAnimation.setAttribute('attributeName', 'opacity');
            cycleFadeInAnimation.setAttribute('from', '0');
            cycleFadeInAnimation.setAttribute('to', pathOpacity.toString());
            cycleFadeInAnimation.setAttribute('dur', '0.5s');
            // Start after each fade-out completes
            cycleFadeInAnimation.setAttribute('begin', `${delay + duration * 0.9}s; ${delay + duration * 1.9}s; ${delay + duration * 2.9}s;`);
            cycleFadeInAnimation.setAttribute('fill', 'freeze');
            
            // Add all the animations to the path
            path.appendChild(fadeInAnimation);
            path.appendChild(strokeAnimation);
            path.appendChild(quickFadeOut);
            path.appendChild(cycleFadeInAnimation);
            
            svg.appendChild(path);
            
            // Add circuit nodes
            if (i % 3 < 2) { // Add nodes to more paths for better coverage
                // Extract coordinates of path turning points
                const matches = d.match(/M(-?\d+),(-?\d+)/g);
                if (matches) {
                    matches.forEach((match, index) => {
                        // Skip some points randomly
                        if (index % 2 === 0 && i % 2 === 0) return; // Skip fewer points
                        
                        const coords = match.match(/M(-?\d+),(-?\d+)/);
                        if (coords && coords.length >= 3) {
                            const cx = parseInt(coords[1]);
                            const cy = parseInt(coords[2]);
                            
                            // Create a small circle at the turning point
                            const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            node.setAttribute('cx', cx);
                            node.setAttribute('cy', cy);
                            node.setAttribute('r', 2 + (i % 3)); // Varied node sizes
                            node.setAttribute('fill', strokeColor);
                            node.setAttribute('opacity', '0');
                            
                            // Add fade in animation
                            const nodeFadeIn = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            nodeFadeIn.setAttribute('attributeName', 'opacity');
                            nodeFadeIn.setAttribute('from', '0');
                            nodeFadeIn.setAttribute('to', (pathOpacity * 1.3).toString());
                            nodeFadeIn.setAttribute('dur', '0.3s');
                            nodeFadeIn.setAttribute('begin', `${delay + 0.1}s; ${delay + duration * 1.1}s; ${delay + duration * 2.1}s;`);
                            nodeFadeIn.setAttribute('fill', 'freeze');
                            
                            // Add fade out animation
                            const nodeFadeOut = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                            nodeFadeOut.setAttribute('attributeName', 'opacity');
                            nodeFadeOut.setAttribute('from', (pathOpacity * 1.3).toString());
                            nodeFadeOut.setAttribute('to', '0');
                            nodeFadeOut.setAttribute('dur', '0.5s');
                            nodeFadeOut.setAttribute('begin', `${delay + duration * 0.3}s; ${delay + duration * 1.3}s; ${delay + duration * 2.3}s;`);
                            nodeFadeOut.setAttribute('fill', 'freeze');
                            
                            // Add animations to node
                            node.appendChild(nodeFadeIn);
                            node.appendChild(nodeFadeOut);
                            
                            // Add node to SVG
                            svg.appendChild(node);
                        }
                    });
                }
            }
        }
    }
    
    // Generate paths initially
    generateAnimatedPaths();
    
    // Regenerate on status change
    const statusObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-status') {
                generateAnimatedPaths();
            }
        });
    });
    
    const wakeBtn = document.querySelector('#wakeHostBtn');
    if (wakeBtn) {
        statusObserver.observe(wakeBtn, { attributes: true });
    }
    
    // Regenerate on resize for responsiveness
    window.addEventListener('resize', debounce(generateAnimatedPaths, 250));
    
    // Helper function for debouncing
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(function() {
                func.apply(context, args);
            }, wait);
        };
    }
});
</script>

<style>
/* Public host page custom styles */
.host-card {
    overflow: hidden;
    border-radius: 1rem;
    transform: translateY(30px);
    opacity: 0;
    position: relative;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.85);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1), 0 5px 10px rgba(0, 0, 0, 0.05);
    transition: all 0.3s var(--animation-spring);
}

.host-card:hover {
    transform: translateY(0) scale(1.02) !important;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15), 0 10px 15px rgba(0, 0, 0, 0.07);
}

/* Animated background */
.animated-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 1rem;
    z-index: 0;
    opacity: 0.9; /* Increased opacity for more visibility */
    transition: opacity 0.5s ease;
}

.animated-paths {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    filter: blur(0.5px); /* Slight blur for a glowing effect */
    transform: translateZ(0); /* Force hardware acceleration */
    overflow: visible !important; /* Allow paths to go outside the SVG for smoother animations */
}

/* Updated SVG positioning to ensure it fills the entire background */
.animated-paths svg {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}

/* Make card content appear above the animated background */
.card-header, .card-body, .card-footer {
    position: relative;
    z-index: 1;
    background-color: transparent !important;
}

.card-header {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color)) !important;
    border-radius: 1rem 1rem 0 0 !important;
}

.card-footer {
    background: rgba(0, 0, 0, 0.03) !important;
    backdrop-filter: blur(5px);
    border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
    border-radius: 0 0 1rem 1rem !important;
}

.bg-gradient-primary {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
}

.icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    border-radius: 10px;
    color: white;
    transition: all 0.3s ease;
}

.icon-mac {
    background-color: var(--primary-color);
    box-shadow: 0 4px 8px rgba(var(--primary-color-rgb), 0.2);
}

.icon-info {
    background-color: var(--accent-color);
    box-shadow: 0 4px 8px rgba(var(--accent-color-rgb), 0.2);
}

.icon-time {
    background-color: var(--secondary-color);
    box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
}

.dark-theme .icon-container {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.mac-address {
    font-family: monospace;
    letter-spacing: 0.5px;
}

.status-indicator {
    display: none;
}

.status-circle {
    display: none;
}

.wake-button {
    display: none;
}

/* Merged wake button with status indicator */
.wake-button-container {
    margin: 20px 0;
    position: relative;
}

.wake-button-circle {
    width: 180px;
    height: 180px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    border: none;
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    color: white;
    transition: all 0.3s ease;
    cursor: pointer;
    padding: 0;
    overflow: hidden;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}

.wake-button-circle::before {
    content: '';
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    bottom: 8px;
    border-radius: 50%;
    border: 4px solid rgba(255, 255, 255, 0.3);
    z-index: 1;
}

.wake-button-circle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 75%;
    height: 75%;
    border-radius: 50%;
    z-index: 0;
    opacity: 0.15;
    transition: all 0.5s ease;
}

.button-inner {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    text-align: center;
}

.power-icon {
    font-size: 2.5rem;
    margin-bottom: 10px;
    transition: all 0.3s ease;
}

.button-text {
    font-weight: 600;
    font-size: 1.1rem;
    letter-spacing: 0.5px;
}

/* Status variations */
.wake-button-circle.online {
    background: linear-gradient(135deg, var(--success-color), #50c878);
    box-shadow: 0 5px 20px rgba(40, 167, 69, 0.4);
}

.wake-button-circle.online::after {
    background-color: var(--success-color);
    animation: wake-button-pulse 2s infinite ease-in-out;
}

.wake-button-circle.offline {
    background: linear-gradient(135deg, var(--danger-color), #ff5757);
    box-shadow: 0 5px 20px rgba(220, 53, 69, 0.4);
}

.wake-button-circle.offline::after {
    background-color: var(--danger-color);
    animation: wake-button-pulse 2s infinite ease-in-out;
}

.wake-button-circle.unknown {
    background: linear-gradient(135deg, var(--secondary-color), #8d98a3);
    box-shadow: 0 5px 20px rgba(108, 117, 125, 0.4);
}

.wake-button-circle.unknown::after {
    background-color: var(--secondary-color);
}

.wake-button-circle:hover {
    transform: translateY(-5px) scale(1.03);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
}

.wake-button-circle:active {
    transform: translateY(2px) scale(0.98);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.wake-button-circle:hover .power-icon {
    transform: scale(1.2);
}

@keyframes wake-button-pulse {
    0% {
        opacity: 0.1;
        transform: translate(-50%, -50%) scale(0.9);
    }
    50% {
        opacity: 0.2;
        transform: translate(-50%, -50%) scale(1.05);
    }
    100% {
        opacity: 0.1;
        transform: translate(-50%, -50%) scale(0.9);
    }
}

/* Enhanced card entrance animation */
@keyframes cardEntrance {
    0% {
        opacity: 0;
        transform: translateY(50px) scale(0.9);
        filter: blur(10px);
    }
    50% {
        opacity: 1;
        filter: blur(0);
    }
    75% {
        transform: translateY(-10px) scale(1.02);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* Dark theme adjustments */
.dark-theme .host-card {
    background-color: rgba(30, 30, 40, 0.85);
    border-color: rgba(255, 255, 255, 0.1);
}

.dark-theme .card-footer {
    background-color: rgba(0, 0, 0, 0.2) !important;
    border-top-color: rgba(255, 255, 255, 0.1) !important;
}

.dark-theme .animated-background {
    opacity: 0.35; /* Increased opacity for dark theme */
}

/* Glowing effect for the wake button in dark mode */
.dark-theme .wake-button-circle {
    box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.5);
}

.dark-theme .wake-button-circle.online {
    box-shadow: 0 0 20px rgba(40, 167, 69, 0.5);
}

.dark-theme .wake-button-circle.offline {
    box-shadow: 0 0 20px rgba(220, 53, 69, 0.5);
}

/* Mobile optimizations */
@media (max-width: 768px) {
    .wake-button-circle {
        width: 150px;
        height: 150px;
    }
    
    .power-icon {
        font-size: 2rem;
    }
    
    .button-text {
        font-size: 1rem;
    }
}

@media (max-width: 576px) {
    .host-card {
        border-radius: 0.75rem;
    }
    
    .card-header {
        border-radius: 0.75rem 0.75rem 0 0 !important;
    }
    
    .card-footer {
        border-radius: 0 0 0.75rem 0.75rem !important;
    }
}
</style>
{% endblock %}
